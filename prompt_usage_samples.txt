---------- instructional file prompt

**Prompt context**:
- use **SYSTEM_PROMPT_v12_FOR_AI_CHAT_FINAL.md** and **WEEKLY_BATCH_GENERATION_PROMPT_v12_FINAL.md** files as starting point, 
- follow **Template_v12_Narrative_FINAL.md file** for structure,
- use **COMPLETE_SYLLABUS_v13_FINAL.md** file for syllabus,
- use MASTER_PROMPT_v12_FINAL.md and SYSTEM_CONFIG_v12_FINAL.md files for context and system config and file naming convention.
- use **Generic_AI_Self_Check_Correction_Step.md** file for error check in generated content and self error correction context


**Action** :
- generate week 11 Day 01 instructional file as downloadable markdown md file, have detailed and structured content for generated file, dont skip any subsection or sub topic. cover topics in detailed.
- strictly follow template structure and file naming convention as per context
- dont use any programming language first, and use only Csharp (c#) / .net language only when required to explain concept or topic or coding example.
- Apply GENERIC AI SELF-CHECK & CORRECTION STEP before output (use **Generic_AI_Self_Check_Correction_Step.md** file):
  1. Verify all references (items, values, indices) exist in problem
  2. Verify logic flow (each step follows logically from previous)
  3. Verify numbers (totals cumulative, counts match actual items)
  4. Verify state consistency (changes tracked, transitions explained)
  5. Verify termination (algorithm stops at correct condition)
  6. Check 7 red flags (input mismatch, logic jump, math error, etc.)
  7. If any issue found â†’ Fix using templates before output
  8. When all checks pass â†’ Generate markdown file
- file naming format is like this
"""
ðŸ“‚ FILE STRUCTURE & NAMING
**Instructional Files:**
- `Week_X_Day_Y_[Topic_Name]_Instructional.md`
- Example: `Week_07_Day_03_Binary_Search_Trees_Instructional.md` (week and day are 2 digit numbers as 01 09, 12, etc)
"""

**important rule**
- ensure all topics and subtopics of the day are covered properly and have sufficient content to explain them, include visual diagrams and visual representations for them.
- extend content and word limit in such scenarios
- If content is exceeding 12,000-18,000 word limit for all required topic and section explanation then don't follow word limit and allo till 30,000 words to be generated.

**Enhancement Rule**: should follow this to enhance content generation 
1. Cover all topics/subtopics for week/day mentioned in syllabus file
2. Make sure generated content is following moto of our dsa mastery course
3. Add and enhance topics/subtopics or contents, which are not part of syllabus subsections but related to [topic] and essential/required for learning following course moto.
4. Recheck all generated content to ensure quality and structure of generated content as per contexts and templates.

---

all reference files that might need for knowing course data and context:

```
COMPLETE_SYLLABUS_v13_FINAL.md
EMOJI_ICON_GUIDE_v12.md
MASTER_PROMPT_v12_FINAL.md
SYSTEM_CONFIG_v12_FINAL.md
SYSTEM_PROMPT_v12_EXTENDED_SUPPORT_CSHARP.md (old csharp template)
SYSTEM_PROMPT_v13_EXTENDED_SUPPORT_CSHARP.md (current ref csharp template)
CONSOLIDATED_CSHARP_EXTENDED_SUPPORT_MASTER_PROMPT_v13 (current csharp template)
SYSTEM_PROMPT_v12_FOR_AI_CHAT_FINAL.md
Template_v12_Narrative_FINAL.md
V12_prompt_usage.md
VISUAL_PLAYBOOK_GENERATION_PROMPT_v12_UPDATED.md
WEEKLY_BATCH_GENERATION_PROMPT_v12_FINAL.md
```

week 11 syllabus as :

"""
## ðŸ“Œ WEEK 11: DYNAMIC PROGRAMMING II - TREES, DAGS & ADVANCED

### Weekly Goal
Extend DP to more complex structures. Master tree DP, DAG DP, bitmask DP, and advanced patterns.

### Weekly Outcomes
- Solve tree DP problems (diameter, maximum independent set)
- Apply DP to DAGs (longest path)
- Solve bitmask DP problems (TSP, subset selection)
- Optimize DP using state compression

### Summary
DP is incredibly powerful. This week extends basic patterns to more complex structures. Students learn when to apply DP, how to design states for different problems, and when to combine DP with other techniques.

---

### ðŸ“… DAY 1: DP ON TREES | 120 min

**Topics:**
- **Tree DP Framework**
  - Solve for each subtree, combine into parent
  - Post-order traversal (solve children before parent)
  - State: what's the answer for this subtree?

- **Maximum Independent Set**
  - Select nodes with no edges between them
  - Maximize value of selected nodes
  - dp[node][0] = max value excluding node
  - dp[node][1] = max value including node
  - Transition: combine children's answers

- **Tree Diameter via DP**
  - Longest path in tree
  - dp[node] = max distance down from node
  - Answer: max(left_depth + right_depth + 1)
  - Time: O(n)

- **Subtree Computation**
  - Simple: sum all nodes in subtree
  - Post-order: solve children, add to node

- **Tree Coloring (K Colors)**
  - Color nodes with K colors, adjacent different
  - dp[node][color] = count of ways
  - Transition: children must use different colors

- **Tree Rerooting (Change Root)**
  - Compute answer when root changes
  - First pass: DP from original root
  - Second pass: reroot and combine

- **Practical Considerations**
  - Space: often work with adjacency list (no explicit table)
  - Time: often O(n) if each node processed once
  - Recursion depth: can hit stack limits for very deep trees

---

### ðŸ“… DAY 2: DP ON DAGS | 120 min

**Topics:**
- **DAG (Directed Acyclic Graph)**
  - Directed graph with no cycles
  - Enables topological ordering
  - DP naturally applies to DAG

- **Longest Path in DAG**
  - No cycles â†’ DP works
  - Topological sort order â†’ compute in order
  - dp[node] = longest path starting at node
  - Transition: max(1 + dp[neighbor] for all neighbors)
  - Time: O(V + E)

- **Shortest Path in DAG with Negative Weights**
  - Bellman-Ford O(VE) needed for general graphs
  - DAG allows O(V + E) via topo sort
  - Process nodes in topo order, relax edges

- **Vertex Weight Sum Paths**
  - Path value = sum of vertex weights (not edge weights)
  - Similar DP but sum vertices instead of edges

- **All Paths in DAG**
  - Count or enumerate paths from s to t
  - DP: dp[node] = number of paths from node to t
  - Transition: sum paths through neighbors

- **Topo Sort Ordering**
  - Critical: must process nodes where all predecessors processed
  - Failure to respect order â†’ wrong answer

- **Longest Path in DAG Applications**
  - Project scheduling: find critical path
  - Game theory: minimax with DAG game state
  - Dependency resolution: find longest dependency chain

---

### ðŸ“… DAY 3: BITMASK & SUBSET DP | 120 min

**Topics:**
- **Bitmask Representation**
  - Set of n elements â†’ bitmask of 2^n states
  - Bit i = 1 if element i in subset
  - Iterate over subsets: 0 to 2^n - 1

- **Subset Enumeration**
  - For each mask: iterate elements to see which included
  - Iterate submasks: clever bit manipulation

- **TSP with DP (Traveling Salesman)**
  - Visit n cities exactly once, minimum cost
  - Naive: O(n!) permutations
  - DP: state = (visited_cities, current_city)
  - dp[mask][last] = min cost visiting cities in mask, ending at last
  - Transition: visit next unvisited city
  - Time: O(2^n Ã— nÂ²)

- **Subset Sum Problems**
  - Count/find subsets with specific sum
  - dp[i] = ways to make sum i
  - Transition: include/exclude elements

- **Maximum Weight Independent Set (Small Graph)**
  - Can use bitmask if vertices few (â‰¤ 20)
  - dp[mask] = max weight with vertices in mask, no edges between
  - Enumerate all masks, check if valid independent set

- **Complexity Analysis**
  - Time: O(2^n Ã— f(n)) where f(n) is work per state
  - Space: O(2^n) for DP table
  - Feasible: n â‰¤ 20, marginal for n â‰¤ 25

- **Bitmask Optimization Techniques**
  - Precompute which masks are valid (no edges)
  - Use bit manipulation tricks (popcount, lowbit, etc.)
  - Prune search space early

---

### ðŸ“… DAY 4 (OPTIONAL): STATE COMPRESSION & OPTIMIZATIONS | 90 min

**Topics:**
- **Space Optimization**
  - Sliding window: keep only current and previous states
  - Example: 2D â†’ 1D if only need previous row
  - Saves from O(m Ã— n) to O(n)

- **Dimension Reduction**
  - 3D DP â†’ 2D by observing what matters
  - Example: coin change with denominations â†’ doesn't need 3D

- **Memoization vs Tabulation Trade-off**
  - Memoization: compute only needed states
  - Tabulation: compute all, more cache-friendly
  - Choose based on state space sparsity

- **Pruning in DP**
  - Skip invalid states
  - Early termination if answer found
  - Example: if current cost exceeds best known, prune

---

### ðŸ“… DAY 5 (OPTIONAL): MIXED DP PROBLEMS | 90 min

**Topics:**
- **Multi-Concept Problems**
  - Combining DP with other algorithms
  - Example: DP on graph shortest paths
  - Example: DP with greedy choices

- **Recognition & Intuition**
  - Overlapping subproblems â†’ DP candidate
  - Optimal substructure â†’ DP candidate
  - Practice: solve many problems builds intuition

- **Problem Solving Strategy**
  - 1. Define state clearly
  - 2. Identify transitions
  - 3. Determine base cases
  - 4. Implement (bottom-up preferred for efficiency)
  - 5. Optimize space if needed
"""

---------- weekly playbook prompt

**Prompt context**:
- use **GENERIC WEEK GENERATION PROMPT TEMPLATE v1.0.md** file to create FULL week 11 PLAYBOOK as a downloadable markdown file.
- Follow correct curriculum mentioned here **COMPLETE_SYLLABUS_v13_FINAL.md.**
- use MASTER_PROMPT_v12_FINAL.md and SYSTEM_CONFIG_v12_FINAL.md files for context and system config and file naming convention.
- use **Generic_AI_Self_Check_Correction_Step.md** file for error check in generated content and self error correction context
 
**Rule and Action**:
- generate WEEK_[x]_FULL_PLAYBOOK.md file for week 11
- provide full file not just quick summary without skipping any topic/subtopic, section/subsection for each day of the week.
- use proper structure and formatting, use appropriate emojis and icons.
- include visual diagram to explain concepts more clearly
- dont use any programming language first, and use only Csharp (c#) .net language only when required to explain concept or topic or coding example.
- Apply GENERIC AI SELF-CHECK & CORRECTION STEP before output (use **Generic_AI_Self_Check_Correction_Step.md** file):
  1. Verify all references (items, values, indices) exist in problem
  2. Verify logic flow (each step follows logically from previous)
  3. Verify numbers (totals cumulative, counts match actual items)
  4. Verify state consistency (changes tracked, transitions explained)
  5. Verify termination (algorithm stops at correct condition)
  6. Check 7 red flags (input mismatch, logic jump, math error, etc.)
  7. If any issue found â†’ Fix using templates before output
  8. When all checks pass â†’ Generate markdown file
- file should be in markdown format
- file naming format is like this
"""
ðŸ“‚ FILE STRUCTURE & NAMING
**WEEK_[x]_FULL_PLAYBOOK.md**
"""

**important rule**
- ensure all topics and subtopics of the day are covered properly and have sufficient content to explain them, include visual diagrams and visual representations for them.
- extend content and word limit in such scenarios
- If content is exceeding 12,000-18,000 word limit for all required topic and section explanation then don't follow word limit and allo till 30,000 words to be generated.

**Enhancement**: should follow this to enhance content generation 
1. Cover all topics/subtopics for week/day mentioned in syllabus file
2. Make sure generated content is following moto of our dsa mastery course
3. Add and enhance topics/subtopics or contents, which are not part of syllabus subsections but related to [topic] and essential/required for learning following course moto.
4. Recheck all generated content to ensure quality and structure of generated content as per contexts and templates.

---

all reference files that might need for knowing course data and context:

```
COMPLETE_SYLLABUS_v13_FINAL.md
EMOJI_ICON_GUIDE_v12.md
MASTER_PROMPT_v12_FINAL.md
SYSTEM_CONFIG_v12_FINAL.md
SYSTEM_PROMPT_v12_EXTENDED_SUPPORT_CSHARP.md (old csharp template)
SYSTEM_PROMPT_v13_EXTENDED_SUPPORT_CSHARP.md (current ref csharp template)
CONSOLIDATED_CSHARP_EXTENDED_SUPPORT_MASTER_PROMPT_v13 (current csharp template)
SYSTEM_PROMPT_v12_FOR_AI_CHAT_FINAL.md
Template_v12_Narrative_FINAL.md
V12_prompt_usage.md
VISUAL_PLAYBOOK_GENERATION_PROMPT_v12_UPDATED.md
WEEKLY_BATCH_GENERATION_PROMPT_v12_FINAL.md
```

week 11 syllabus as :

"""
## ðŸ“Œ WEEK 11: DYNAMIC PROGRAMMING II - TREES, DAGS & ADVANCED

### Weekly Goal
Extend DP to more complex structures. Master tree DP, DAG DP, bitmask DP, and advanced patterns.

### Weekly Outcomes
- Solve tree DP problems (diameter, maximum independent set)
- Apply DP to DAGs (longest path)
- Solve bitmask DP problems (TSP, subset selection)
- Optimize DP using state compression

### Summary
DP is incredibly powerful. This week extends basic patterns to more complex structures. Students learn when to apply DP, how to design states for different problems, and when to combine DP with other techniques.

---

### ðŸ“… DAY 1: DP ON TREES | 120 min

**Topics:**
- **Tree DP Framework**
  - Solve for each subtree, combine into parent
  - Post-order traversal (solve children before parent)
  - State: what's the answer for this subtree?

- **Maximum Independent Set**
  - Select nodes with no edges between them
  - Maximize value of selected nodes
  - dp[node][0] = max value excluding node
  - dp[node][1] = max value including node
  - Transition: combine children's answers

- **Tree Diameter via DP**
  - Longest path in tree
  - dp[node] = max distance down from node
  - Answer: max(left_depth + right_depth + 1)
  - Time: O(n)

- **Subtree Computation**
  - Simple: sum all nodes in subtree
  - Post-order: solve children, add to node

- **Tree Coloring (K Colors)**
  - Color nodes with K colors, adjacent different
  - dp[node][color] = count of ways
  - Transition: children must use different colors

- **Tree Rerooting (Change Root)**
  - Compute answer when root changes
  - First pass: DP from original root
  - Second pass: reroot and combine

- **Practical Considerations**
  - Space: often work with adjacency list (no explicit table)
  - Time: often O(n) if each node processed once
  - Recursion depth: can hit stack limits for very deep trees

---

### ðŸ“… DAY 2: DP ON DAGS | 120 min

**Topics:**
- **DAG (Directed Acyclic Graph)**
  - Directed graph with no cycles
  - Enables topological ordering
  - DP naturally applies to DAG

- **Longest Path in DAG**
  - No cycles â†’ DP works
  - Topological sort order â†’ compute in order
  - dp[node] = longest path starting at node
  - Transition: max(1 + dp[neighbor] for all neighbors)
  - Time: O(V + E)

- **Shortest Path in DAG with Negative Weights**
  - Bellman-Ford O(VE) needed for general graphs
  - DAG allows O(V + E) via topo sort
  - Process nodes in topo order, relax edges

- **Vertex Weight Sum Paths**
  - Path value = sum of vertex weights (not edge weights)
  - Similar DP but sum vertices instead of edges

- **All Paths in DAG**
  - Count or enumerate paths from s to t
  - DP: dp[node] = number of paths from node to t
  - Transition: sum paths through neighbors

- **Topo Sort Ordering**
  - Critical: must process nodes where all predecessors processed
  - Failure to respect order â†’ wrong answer

- **Longest Path in DAG Applications**
  - Project scheduling: find critical path
  - Game theory: minimax with DAG game state
  - Dependency resolution: find longest dependency chain

---

### ðŸ“… DAY 3: BITMASK & SUBSET DP | 120 min

**Topics:**
- **Bitmask Representation**
  - Set of n elements â†’ bitmask of 2^n states
  - Bit i = 1 if element i in subset
  - Iterate over subsets: 0 to 2^n - 1

- **Subset Enumeration**
  - For each mask: iterate elements to see which included
  - Iterate submasks: clever bit manipulation

- **TSP with DP (Traveling Salesman)**
  - Visit n cities exactly once, minimum cost
  - Naive: O(n!) permutations
  - DP: state = (visited_cities, current_city)
  - dp[mask][last] = min cost visiting cities in mask, ending at last
  - Transition: visit next unvisited city
  - Time: O(2^n Ã— nÂ²)

- **Subset Sum Problems**
  - Count/find subsets with specific sum
  - dp[i] = ways to make sum i
  - Transition: include/exclude elements

- **Maximum Weight Independent Set (Small Graph)**
  - Can use bitmask if vertices few (â‰¤ 20)
  - dp[mask] = max weight with vertices in mask, no edges between
  - Enumerate all masks, check if valid independent set

- **Complexity Analysis**
  - Time: O(2^n Ã— f(n)) where f(n) is work per state
  - Space: O(2^n) for DP table
  - Feasible: n â‰¤ 20, marginal for n â‰¤ 25

- **Bitmask Optimization Techniques**
  - Precompute which masks are valid (no edges)
  - Use bit manipulation tricks (popcount, lowbit, etc.)
  - Prune search space early

---

### ðŸ“… DAY 4 (OPTIONAL): STATE COMPRESSION & OPTIMIZATIONS | 90 min

**Topics:**
- **Space Optimization**
  - Sliding window: keep only current and previous states
  - Example: 2D â†’ 1D if only need previous row
  - Saves from O(m Ã— n) to O(n)

- **Dimension Reduction**
  - 3D DP â†’ 2D by observing what matters
  - Example: coin change with denominations â†’ doesn't need 3D

- **Memoization vs Tabulation Trade-off**
  - Memoization: compute only needed states
  - Tabulation: compute all, more cache-friendly
  - Choose based on state space sparsity

- **Pruning in DP**
  - Skip invalid states
  - Early termination if answer found
  - Example: if current cost exceeds best known, prune

---

### ðŸ“… DAY 5 (OPTIONAL): MIXED DP PROBLEMS | 90 min

**Topics:**
- **Multi-Concept Problems**
  - Combining DP with other algorithms
  - Example: DP on graph shortest paths
  - Example: DP with greedy choices

- **Recognition & Intuition**
  - Overlapping subproblems â†’ DP candidate
  - Optimal substructure â†’ DP candidate
  - Practice: solve many problems builds intuition

- **Problem Solving Strategy**
  - 1. Define state clearly
  - 2. Identify transitions
  - 3. Determine base cases
  - 4. Implement (bottom-up preferred for efficiency)
  - 5. Optimize space if needed
"""

----------- visual playbook file prompt

**Prompt context**:
- use **VISUAL_PLAYBOOK_GENERATION_PROMPT_v12_UPDATED.md** file as starting point, 
- use **COMPLETE_SYLLABUS_v13_FINAL.md** file for syllabus,
- use MASTER_PROMPT_v12_FINAL.md and SYSTEM_CONFIG_v12_FINAL.md files for context and system config  and file naming convention.
- use **Generic_AI_Self_Check_Correction_Step.md** file for error check in generated content and self error correction context

**Action** :
- generate week 11 visual hybrid support md file, have detailed and structured content for generated file, dont skip any subsection or sub topic. cover topics in detailed.
- strictly follow template structure and file naming convention as per context
- use visual diagrams, charts and external visual images and resources that will help explain concept clearly
- Apply GENERIC AI SELF-CHECK & CORRECTION STEP before output (use **Generic_AI_Self_Check_Correction_Step.md** file):
  1. Verify all references (items, values, indices) exist in problem
  2. Verify logic flow (each step follows logically from previous)
  3. Verify numbers (totals cumulative, counts match actual items)
  4. Verify state consistency (changes tracked, transitions explained)
  5. Verify termination (algorithm stops at correct condition)
  6. Check 7 red flags (input mismatch, logic jump, math error, etc.)
  7. If any issue found â†’ Fix using templates before output
  8. When all checks pass â†’ Generate markdown file
- file naming format is like this
"""
FILENAME: Week_[WEEK_NUMBER]_Visual_Concepts_Playbook_HYBRID.md (2 digit week number like 01, 09, 12)
"""

**important rule**
- ensure all topics and subtopics of the day are covered properly and have sufficient content to explain them, include visual diagrams and visual representations for them.
- extend content and word limit in such scenarios
- If content is exceeding 12,000-18,000 word limit for all required topic and section explanation then don't follow word limit and allo till 30,000 words to be generated.

**Enhancement**: should follow this to enhance content generation
1. Cover all topics/subtopics for week/day mentioned in syllabus file
2. Make sure generated content is following moto of our dsa mastery course
3. Add and enhance topics/subtopics or contents, which are not part of syllabus subsections but related to [topic] and essential/required for learning following course moto.
4. Recheck all generated content to ensure quality and structure of generated content as per contexts and templates.

---

all reference files that might need for knowing course data and context:

```
COMPLETE_SYLLABUS_v13_FINAL.md
EMOJI_ICON_GUIDE_v12.md
MASTER_PROMPT_v12_FINAL.md
SYSTEM_CONFIG_v12_FINAL.md
SYSTEM_PROMPT_v12_EXTENDED_SUPPORT_CSHARP.md (old csharp template)
SYSTEM_PROMPT_v13_EXTENDED_SUPPORT_CSHARP.md (current ref csharp template)
CONSOLIDATED_CSHARP_EXTENDED_SUPPORT_MASTER_PROMPT_v13 (current csharp template)
SYSTEM_PROMPT_v12_FOR_AI_CHAT_FINAL.md
Template_v12_Narrative_FINAL.md
V12_prompt_usage.md
VISUAL_PLAYBOOK_GENERATION_PROMPT_v12_UPDATED.md
WEEKLY_BATCH_GENERATION_PROMPT_v12_FINAL.md
```

week 11 syllabus as :

"""
## ðŸ“Œ WEEK 11: DYNAMIC PROGRAMMING II - TREES, DAGS & ADVANCED

### Weekly Goal
Extend DP to more complex structures. Master tree DP, DAG DP, bitmask DP, and advanced patterns.

### Weekly Outcomes
- Solve tree DP problems (diameter, maximum independent set)
- Apply DP to DAGs (longest path)
- Solve bitmask DP problems (TSP, subset selection)
- Optimize DP using state compression

### Summary
DP is incredibly powerful. This week extends basic patterns to more complex structures. Students learn when to apply DP, how to design states for different problems, and when to combine DP with other techniques.

---

### ðŸ“… DAY 1: DP ON TREES | 120 min

**Topics:**
- **Tree DP Framework**
  - Solve for each subtree, combine into parent
  - Post-order traversal (solve children before parent)
  - State: what's the answer for this subtree?

- **Maximum Independent Set**
  - Select nodes with no edges between them
  - Maximize value of selected nodes
  - dp[node][0] = max value excluding node
  - dp[node][1] = max value including node
  - Transition: combine children's answers

- **Tree Diameter via DP**
  - Longest path in tree
  - dp[node] = max distance down from node
  - Answer: max(left_depth + right_depth + 1)
  - Time: O(n)

- **Subtree Computation**
  - Simple: sum all nodes in subtree
  - Post-order: solve children, add to node

- **Tree Coloring (K Colors)**
  - Color nodes with K colors, adjacent different
  - dp[node][color] = count of ways
  - Transition: children must use different colors

- **Tree Rerooting (Change Root)**
  - Compute answer when root changes
  - First pass: DP from original root
  - Second pass: reroot and combine

- **Practical Considerations**
  - Space: often work with adjacency list (no explicit table)
  - Time: often O(n) if each node processed once
  - Recursion depth: can hit stack limits for very deep trees

---

### ðŸ“… DAY 2: DP ON DAGS | 120 min

**Topics:**
- **DAG (Directed Acyclic Graph)**
  - Directed graph with no cycles
  - Enables topological ordering
  - DP naturally applies to DAG

- **Longest Path in DAG**
  - No cycles â†’ DP works
  - Topological sort order â†’ compute in order
  - dp[node] = longest path starting at node
  - Transition: max(1 + dp[neighbor] for all neighbors)
  - Time: O(V + E)

- **Shortest Path in DAG with Negative Weights**
  - Bellman-Ford O(VE) needed for general graphs
  - DAG allows O(V + E) via topo sort
  - Process nodes in topo order, relax edges

- **Vertex Weight Sum Paths**
  - Path value = sum of vertex weights (not edge weights)
  - Similar DP but sum vertices instead of edges

- **All Paths in DAG**
  - Count or enumerate paths from s to t
  - DP: dp[node] = number of paths from node to t
  - Transition: sum paths through neighbors

- **Topo Sort Ordering**
  - Critical: must process nodes where all predecessors processed
  - Failure to respect order â†’ wrong answer

- **Longest Path in DAG Applications**
  - Project scheduling: find critical path
  - Game theory: minimax with DAG game state
  - Dependency resolution: find longest dependency chain

---

### ðŸ“… DAY 3: BITMASK & SUBSET DP | 120 min

**Topics:**
- **Bitmask Representation**
  - Set of n elements â†’ bitmask of 2^n states
  - Bit i = 1 if element i in subset
  - Iterate over subsets: 0 to 2^n - 1

- **Subset Enumeration**
  - For each mask: iterate elements to see which included
  - Iterate submasks: clever bit manipulation

- **TSP with DP (Traveling Salesman)**
  - Visit n cities exactly once, minimum cost
  - Naive: O(n!) permutations
  - DP: state = (visited_cities, current_city)
  - dp[mask][last] = min cost visiting cities in mask, ending at last
  - Transition: visit next unvisited city
  - Time: O(2^n Ã— nÂ²)

- **Subset Sum Problems**
  - Count/find subsets with specific sum
  - dp[i] = ways to make sum i
  - Transition: include/exclude elements

- **Maximum Weight Independent Set (Small Graph)**
  - Can use bitmask if vertices few (â‰¤ 20)
  - dp[mask] = max weight with vertices in mask, no edges between
  - Enumerate all masks, check if valid independent set

- **Complexity Analysis**
  - Time: O(2^n Ã— f(n)) where f(n) is work per state
  - Space: O(2^n) for DP table
  - Feasible: n â‰¤ 20, marginal for n â‰¤ 25

- **Bitmask Optimization Techniques**
  - Precompute which masks are valid (no edges)
  - Use bit manipulation tricks (popcount, lowbit, etc.)
  - Prune search space early

---

### ðŸ“… DAY 4 (OPTIONAL): STATE COMPRESSION & OPTIMIZATIONS | 90 min

**Topics:**
- **Space Optimization**
  - Sliding window: keep only current and previous states
  - Example: 2D â†’ 1D if only need previous row
  - Saves from O(m Ã— n) to O(n)

- **Dimension Reduction**
  - 3D DP â†’ 2D by observing what matters
  - Example: coin change with denominations â†’ doesn't need 3D

- **Memoization vs Tabulation Trade-off**
  - Memoization: compute only needed states
  - Tabulation: compute all, more cache-friendly
  - Choose based on state space sparsity

- **Pruning in DP**
  - Skip invalid states
  - Early termination if answer found
  - Example: if current cost exceeds best known, prune

---

### ðŸ“… DAY 5 (OPTIONAL): MIXED DP PROBLEMS | 90 min

**Topics:**
- **Multi-Concept Problems**
  - Combining DP with other algorithms
  - Example: DP on graph shortest paths
  - Example: DP with greedy choices

- **Recognition & Intuition**
  - Overlapping subproblems â†’ DP candidate
  - Optimal substructure â†’ DP candidate
  - Practice: solve many problems builds intuition

- **Problem Solving Strategy**
  - 1. Define state clearly
  - 2. Identify transitions
  - 3. Determine base cases
  - 4. Implement (bottom-up preferred for efficiency)
  - 5. Optimize space if needed
"""

------- csharp support file prompt

**Prompt context**:
- use **CONSOLIDATED_CSHARP_EXTENDED_SUPPORT_MASTER_PROMPT_v13.md** file as starting point, 
- use **SYSTEM_PROMPT_v13_EXTENDED_SUPPORT_CSHARP.md** and **SYSTEM_PROMPT_v12_EXTENDED_SUPPORT_CSHARP.md** files as reference
- use **COMPLETE_SYLLABUS_v13_FINAL.md** file for syllabus,
- use MASTER_PROMPT_v12_FINAL.md and SYSTEM_CONFIG_v12_FINAL.md files for context and system config and file naming convention.
- use **Generic_AI_Self_Check_Correction_Step.md** file for error check in generated content and self error correction context

**Action** :
- generate week 07 Csharp extended support md file, have detailed and structured content for generated file, dont skip any subsection or sub topic. cover topics in detailed.
- strictly follow template structure and file naming convention as per context
- Apply GENERIC AI SELF-CHECK & CORRECTION STEP before output (use **Generic_AI_Self_Check_Correction_Step.md** file):
  1. Verify all references (items, values, indices) exist in problem
  2. Verify logic flow (each step follows logically from previous)
  3. Verify numbers (totals cumulative, counts match actual items)
  4. Verify state consistency (changes tracked, transitions explained)
  5. Verify termination (algorithm stops at correct condition)
  6. Check 7 red flags (input mismatch, logic jump, math error, etc.)
  7. If any issue found â†’ Fix using templates before output
  8. When all checks pass â†’ Generate markdown file
- file naming format is like this
"""
ðŸ“‚ FILE STRUCTURE & NAMING
**Week_[X]_Extended_CSharp_Problem_Solving_Implementation.md**
"""

**important rule**
- ensure all topics and subtopics of the day are covered properly and have sufficient content to explain them, include visual diagrams and visual representations for them.
- extend content and word limit in such scenarios
- If content is exceeding 12,000-18,000 word limit for all required topic and section explanation then don't follow word limit and allo till 30,000 words to be generated.

**Enhancement**: should follow this to enhance content generation 
1. Cover all topics/subtopics for week/day mentioned in syllabus file
2. Make sure generated content is following moto of our dsa mastery course
3. Add and enhance topics/subtopics or contents, which are not part of syllabus subsections but related to [topic] and essential/required for learning following course moto.
4. Recheck all generated content to ensure quality and structure of generated content as per contexts and templates.

---

all reference files that might need for knowing course data and context:

```
COMPLETE_SYLLABUS_v13_FINAL.md
EMOJI_ICON_GUIDE_v12.md
MASTER_PROMPT_v12_FINAL.md
SYSTEM_CONFIG_v12_FINAL.md
SYSTEM_PROMPT_v12_EXTENDED_SUPPORT_CSHARP.md (old csharp template)
SYSTEM_PROMPT_v13_EXTENDED_SUPPORT_CSHARP.md (current ref csharp template)
CONSOLIDATED_CSHARP_EXTENDED_SUPPORT_MASTER_PROMPT_v13 (current csharp template)
SYSTEM_PROMPT_v12_FOR_AI_CHAT_FINAL.md
Template_v12_Narrative_FINAL.md
V12_prompt_usage.md
VISUAL_PLAYBOOK_GENERATION_PROMPT_v12_UPDATED.md
WEEKLY_BATCH_GENERATION_PROMPT_v12_FINAL.md
```

week 11 syllabus as :

"""
## ðŸ“Œ WEEK 11: DYNAMIC PROGRAMMING II - TREES, DAGS & ADVANCED

### Weekly Goal
Extend DP to more complex structures. Master tree DP, DAG DP, bitmask DP, and advanced patterns.

### Weekly Outcomes
- Solve tree DP problems (diameter, maximum independent set)
- Apply DP to DAGs (longest path)
- Solve bitmask DP problems (TSP, subset selection)
- Optimize DP using state compression

### Summary
DP is incredibly powerful. This week extends basic patterns to more complex structures. Students learn when to apply DP, how to design states for different problems, and when to combine DP with other techniques.

---

### ðŸ“… DAY 1: DP ON TREES | 120 min

**Topics:**
- **Tree DP Framework**
  - Solve for each subtree, combine into parent
  - Post-order traversal (solve children before parent)
  - State: what's the answer for this subtree?

- **Maximum Independent Set**
  - Select nodes with no edges between them
  - Maximize value of selected nodes
  - dp[node][0] = max value excluding node
  - dp[node][1] = max value including node
  - Transition: combine children's answers

- **Tree Diameter via DP**
  - Longest path in tree
  - dp[node] = max distance down from node
  - Answer: max(left_depth + right_depth + 1)
  - Time: O(n)

- **Subtree Computation**
  - Simple: sum all nodes in subtree
  - Post-order: solve children, add to node

- **Tree Coloring (K Colors)**
  - Color nodes with K colors, adjacent different
  - dp[node][color] = count of ways
  - Transition: children must use different colors

- **Tree Rerooting (Change Root)**
  - Compute answer when root changes
  - First pass: DP from original root
  - Second pass: reroot and combine

- **Practical Considerations**
  - Space: often work with adjacency list (no explicit table)
  - Time: often O(n) if each node processed once
  - Recursion depth: can hit stack limits for very deep trees

---

### ðŸ“… DAY 2: DP ON DAGS | 120 min

**Topics:**
- **DAG (Directed Acyclic Graph)**
  - Directed graph with no cycles
  - Enables topological ordering
  - DP naturally applies to DAG

- **Longest Path in DAG**
  - No cycles â†’ DP works
  - Topological sort order â†’ compute in order
  - dp[node] = longest path starting at node
  - Transition: max(1 + dp[neighbor] for all neighbors)
  - Time: O(V + E)

- **Shortest Path in DAG with Negative Weights**
  - Bellman-Ford O(VE) needed for general graphs
  - DAG allows O(V + E) via topo sort
  - Process nodes in topo order, relax edges

- **Vertex Weight Sum Paths**
  - Path value = sum of vertex weights (not edge weights)
  - Similar DP but sum vertices instead of edges

- **All Paths in DAG**
  - Count or enumerate paths from s to t
  - DP: dp[node] = number of paths from node to t
  - Transition: sum paths through neighbors

- **Topo Sort Ordering**
  - Critical: must process nodes where all predecessors processed
  - Failure to respect order â†’ wrong answer

- **Longest Path in DAG Applications**
  - Project scheduling: find critical path
  - Game theory: minimax with DAG game state
  - Dependency resolution: find longest dependency chain

---

### ðŸ“… DAY 3: BITMASK & SUBSET DP | 120 min

**Topics:**
- **Bitmask Representation**
  - Set of n elements â†’ bitmask of 2^n states
  - Bit i = 1 if element i in subset
  - Iterate over subsets: 0 to 2^n - 1

- **Subset Enumeration**
  - For each mask: iterate elements to see which included
  - Iterate submasks: clever bit manipulation

- **TSP with DP (Traveling Salesman)**
  - Visit n cities exactly once, minimum cost
  - Naive: O(n!) permutations
  - DP: state = (visited_cities, current_city)
  - dp[mask][last] = min cost visiting cities in mask, ending at last
  - Transition: visit next unvisited city
  - Time: O(2^n Ã— nÂ²)

- **Subset Sum Problems**
  - Count/find subsets with specific sum
  - dp[i] = ways to make sum i
  - Transition: include/exclude elements

- **Maximum Weight Independent Set (Small Graph)**
  - Can use bitmask if vertices few (â‰¤ 20)
  - dp[mask] = max weight with vertices in mask, no edges between
  - Enumerate all masks, check if valid independent set

- **Complexity Analysis**
  - Time: O(2^n Ã— f(n)) where f(n) is work per state
  - Space: O(2^n) for DP table
  - Feasible: n â‰¤ 20, marginal for n â‰¤ 25

- **Bitmask Optimization Techniques**
  - Precompute which masks are valid (no edges)
  - Use bit manipulation tricks (popcount, lowbit, etc.)
  - Prune search space early

---

### ðŸ“… DAY 4 (OPTIONAL): STATE COMPRESSION & OPTIMIZATIONS | 90 min

**Topics:**
- **Space Optimization**
  - Sliding window: keep only current and previous states
  - Example: 2D â†’ 1D if only need previous row
  - Saves from O(m Ã— n) to O(n)

- **Dimension Reduction**
  - 3D DP â†’ 2D by observing what matters
  - Example: coin change with denominations â†’ doesn't need 3D

- **Memoization vs Tabulation Trade-off**
  - Memoization: compute only needed states
  - Tabulation: compute all, more cache-friendly
  - Choose based on state space sparsity

- **Pruning in DP**
  - Skip invalid states
  - Early termination if answer found
  - Example: if current cost exceeds best known, prune

---

### ðŸ“… DAY 5 (OPTIONAL): MIXED DP PROBLEMS | 90 min

**Topics:**
- **Multi-Concept Problems**
  - Combining DP with other algorithms
  - Example: DP on graph shortest paths
  - Example: DP with greedy choices

- **Recognition & Intuition**
  - Overlapping subproblems â†’ DP candidate
  - Optimal substructure â†’ DP candidate
  - Practice: solve many problems builds intuition

- **Problem Solving Strategy**
  - 1. Define state clearly
  - 2. Identify transitions
  - 3. Determine base cases
  - 4. Implement (bottom-up preferred for efficiency)
  - 5. Optimize space if needed
"""

---------- support file prompt

**Prompt context**:
- use **SYSTEM_PROMPT_v12_FOR_AI_CHAT_FINAL.md** and **WEEKLY_BATCH_GENERATION_PROMPT_v12_FINAL.md** files as starting point, 
- follow **Template_v12_Narrative_FINAL.md file** for structure,
- use **COMPLETE_SYLLABUS_v13_FINAL.md** file for syllabus,
- use MASTER_PROMPT_v12_FINAL.md and SYSTEM_CONFIG_v12_FINAL.md files for context and system config  and file naming convention.
- use **Generic_AI_Self_Check_Correction_Step.md** file for error check in generated content and self error correction context

**Action** :
- generate week 11 Support files, 
"""
- `Week_X_Guidelines.md`
- `Week_X_Summary_Key_Concepts.md`
- `Week_X_Daily_Progress_Checklist.md`
"""
- have detailed and structured content for generated file, dont skip any subsection or sub topic. cover topics in detailed.
- strictly follow template structure and file naming convention as per context
- Apply GENERIC AI SELF-CHECK & CORRECTION STEP before output (use **Generic_AI_Self_Check_Correction_Step.md** file):
1. Verify all references (items, values, indices) exist in problem
2. Verify logic flow (each step follows logically from previous)
3. Verify numbers (totals cumulative, counts match actual items)
4. Verify state consistency (changes tracked, transitions explained)
5. Verify termination (algorithm stops at correct condition)
6. Check 7 red flags (input mismatch, logic jump, math error, etc.)
7. If any issue found â†’ Fix using templates before output
8. When all checks pass â†’ Generate markdown file
- file naming format is like this
"""
ðŸ“‚ FILE STRUCTURE & NAMING
**Support Files:**
- `Week_X_Guidelines.md`
- `Week_X_Summary_Key_Concepts.md`
- `Week_X_Interview_QA_Reference.md`
- `Week_X_Problem_Solving_Roadmap.md`
- `Week_X_Daily_Progress_Checklist.md`
"""

**Enhancement**: should follow this to enhance content generation 

1. Cover all topics/subtopics for week/day mentioned in syllabus file
2. Make sure generated content is following moto of our dsa mastery course
3. Add and enhance topics/subtopics or contents, which are not part of syllabus subsections but related to [topic] and essential/required for learning following course moto.
4. Recheck all generated content to ensure quality and structure of generated content as per contexts and templates.

---

all reference files that might need for knowing course data and context:

```
COMPLETE_SYLLABUS_v13_FINAL.md
EMOJI_ICON_GUIDE_v12.md
MASTER_PROMPT_v12_FINAL.md
SYSTEM_CONFIG_v12_FINAL.md
SYSTEM_PROMPT_v12_EXTENDED_SUPPORT_CSHARP.md (old csharp template)
SYSTEM_PROMPT_v13_EXTENDED_SUPPORT_CSHARP.md (current ref csharp template)
CONSOLIDATED_CSHARP_EXTENDED_SUPPORT_MASTER_PROMPT_v13 (current csharp template)
SYSTEM_PROMPT_v12_FOR_AI_CHAT_FINAL.md
Template_v12_Narrative_FINAL.md
V12_prompt_usage.md
VISUAL_PLAYBOOK_GENERATION_PROMPT_v12_UPDATED.md
WEEKLY_BATCH_GENERATION_PROMPT_v12_FINAL.md
```

week 11 syllabus as :

"""
## ðŸ“Œ WEEK 11: DYNAMIC PROGRAMMING II - TREES, DAGS & ADVANCED

### Weekly Goal
Extend DP to more complex structures. Master tree DP, DAG DP, bitmask DP, and advanced patterns.

### Weekly Outcomes
- Solve tree DP problems (diameter, maximum independent set)
- Apply DP to DAGs (longest path)
- Solve bitmask DP problems (TSP, subset selection)
- Optimize DP using state compression

### Summary
DP is incredibly powerful. This week extends basic patterns to more complex structures. Students learn when to apply DP, how to design states for different problems, and when to combine DP with other techniques.

---

### ðŸ“… DAY 1: DP ON TREES | 120 min

**Topics:**
- **Tree DP Framework**
  - Solve for each subtree, combine into parent
  - Post-order traversal (solve children before parent)
  - State: what's the answer for this subtree?

- **Maximum Independent Set**
  - Select nodes with no edges between them
  - Maximize value of selected nodes
  - dp[node][0] = max value excluding node
  - dp[node][1] = max value including node
  - Transition: combine children's answers

- **Tree Diameter via DP**
  - Longest path in tree
  - dp[node] = max distance down from node
  - Answer: max(left_depth + right_depth + 1)
  - Time: O(n)

- **Subtree Computation**
  - Simple: sum all nodes in subtree
  - Post-order: solve children, add to node

- **Tree Coloring (K Colors)**
  - Color nodes with K colors, adjacent different
  - dp[node][color] = count of ways
  - Transition: children must use different colors

- **Tree Rerooting (Change Root)**
  - Compute answer when root changes
  - First pass: DP from original root
  - Second pass: reroot and combine

- **Practical Considerations**
  - Space: often work with adjacency list (no explicit table)
  - Time: often O(n) if each node processed once
  - Recursion depth: can hit stack limits for very deep trees

---

### ðŸ“… DAY 2: DP ON DAGS | 120 min

**Topics:**
- **DAG (Directed Acyclic Graph)**
  - Directed graph with no cycles
  - Enables topological ordering
  - DP naturally applies to DAG

- **Longest Path in DAG**
  - No cycles â†’ DP works
  - Topological sort order â†’ compute in order
  - dp[node] = longest path starting at node
  - Transition: max(1 + dp[neighbor] for all neighbors)
  - Time: O(V + E)

- **Shortest Path in DAG with Negative Weights**
  - Bellman-Ford O(VE) needed for general graphs
  - DAG allows O(V + E) via topo sort
  - Process nodes in topo order, relax edges

- **Vertex Weight Sum Paths**
  - Path value = sum of vertex weights (not edge weights)
  - Similar DP but sum vertices instead of edges

- **All Paths in DAG**
  - Count or enumerate paths from s to t
  - DP: dp[node] = number of paths from node to t
  - Transition: sum paths through neighbors

- **Topo Sort Ordering**
  - Critical: must process nodes where all predecessors processed
  - Failure to respect order â†’ wrong answer

- **Longest Path in DAG Applications**
  - Project scheduling: find critical path
  - Game theory: minimax with DAG game state
  - Dependency resolution: find longest dependency chain

---

### ðŸ“… DAY 3: BITMASK & SUBSET DP | 120 min

**Topics:**
- **Bitmask Representation**
  - Set of n elements â†’ bitmask of 2^n states
  - Bit i = 1 if element i in subset
  - Iterate over subsets: 0 to 2^n - 1

- **Subset Enumeration**
  - For each mask: iterate elements to see which included
  - Iterate submasks: clever bit manipulation

- **TSP with DP (Traveling Salesman)**
  - Visit n cities exactly once, minimum cost
  - Naive: O(n!) permutations
  - DP: state = (visited_cities, current_city)
  - dp[mask][last] = min cost visiting cities in mask, ending at last
  - Transition: visit next unvisited city
  - Time: O(2^n Ã— nÂ²)

- **Subset Sum Problems**
  - Count/find subsets with specific sum
  - dp[i] = ways to make sum i
  - Transition: include/exclude elements

- **Maximum Weight Independent Set (Small Graph)**
  - Can use bitmask if vertices few (â‰¤ 20)
  - dp[mask] = max weight with vertices in mask, no edges between
  - Enumerate all masks, check if valid independent set

- **Complexity Analysis**
  - Time: O(2^n Ã— f(n)) where f(n) is work per state
  - Space: O(2^n) for DP table
  - Feasible: n â‰¤ 20, marginal for n â‰¤ 25

- **Bitmask Optimization Techniques**
  - Precompute which masks are valid (no edges)
  - Use bit manipulation tricks (popcount, lowbit, etc.)
  - Prune search space early

---

### ðŸ“… DAY 4 (OPTIONAL): STATE COMPRESSION & OPTIMIZATIONS | 90 min

**Topics:**
- **Space Optimization**
  - Sliding window: keep only current and previous states
  - Example: 2D â†’ 1D if only need previous row
  - Saves from O(m Ã— n) to O(n)

- **Dimension Reduction**
  - 3D DP â†’ 2D by observing what matters
  - Example: coin change with denominations â†’ doesn't need 3D

- **Memoization vs Tabulation Trade-off**
  - Memoization: compute only needed states
  - Tabulation: compute all, more cache-friendly
  - Choose based on state space sparsity

- **Pruning in DP**
  - Skip invalid states
  - Early termination if answer found
  - Example: if current cost exceeds best known, prune

---

### ðŸ“… DAY 5 (OPTIONAL): MIXED DP PROBLEMS | 90 min

**Topics:**
- **Multi-Concept Problems**
  - Combining DP with other algorithms
  - Example: DP on graph shortest paths
  - Example: DP with greedy choices

- **Recognition & Intuition**
  - Overlapping subproblems â†’ DP candidate
  - Optimal substructure â†’ DP candidate
  - Practice: solve many problems builds intuition

- **Problem Solving Strategy**
  - 1. Define state clearly
  - 2. Identify transitions
  - 3. Determine base cases
  - 4. Implement (bottom-up preferred for efficiency)
  - 5. Optimize space if needed
"""